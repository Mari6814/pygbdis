from .disassembler import Disassembler
from .context import Context
from .disassembly import Disassembly

class GBC(Disassembler):
    def initialize_instructions(self):
        self.add_instruction(0x06, lambda ctx: Disassembly('ld B, {n}', n=ctx.pop8()))
        self.add_instruction(0x0E, lambda ctx: Disassembly('ld C, {n}', n=ctx.pop8()))
        self.add_instruction(0x16, lambda ctx: Disassembly('ld D, {n}', n=ctx.pop8()))
        self.add_instruction(0x1E, lambda ctx: Disassembly('ld E, {n}', n=ctx.pop8()))
        self.add_instruction(0x26, lambda ctx: Disassembly('ld H, {n}', n=ctx.pop8()))
        self.add_instruction(0x2E, lambda ctx: Disassembly('ld L, {n}', n=ctx.pop8()))
        self.add_instruction(0x7F, 'ld A, A')
        self.add_instruction(0x78, 'ld A, B')
        self.add_instruction(0x79, 'ld A, C')
        self.add_instruction(0x7A, 'ld A, D')
        self.add_instruction(0x7B, 'ld A, E')
        self.add_instruction(0x7C, 'ld A, H')
        self.add_instruction(0x7D, 'ld A, L')
        self.add_instruction(0x7E, 'ld A, [HL]')
        self.add_instruction(0x40, 'ld B, B')
        self.add_instruction(0x41, 'ld B, C')
        self.add_instruction(0x42, 'ld B, D')
        self.add_instruction(0x43, 'ld B, E')
        self.add_instruction(0x44, 'ld B, H')
        self.add_instruction(0x45, 'ld B, L')
        self.add_instruction(0x46, 'ld B, [HL]')
        self.add_instruction(0x48, 'ld C, B')
        self.add_instruction(0x49, 'ld C, C')
        self.add_instruction(0x4A, 'ld C, D')
        self.add_instruction(0x4B, 'ld C, E')
        self.add_instruction(0x4C, 'ld C, H')
        self.add_instruction(0x4D, 'ld C, L')
        self.add_instruction(0x4E, 'ld C, [HL]')
        self.add_instruction(0x50, 'ld D, B')
        self.add_instruction(0x51, 'ld D, C')
        self.add_instruction(0x52, 'ld D, D')
        self.add_instruction(0x53, 'ld D, E')
        self.add_instruction(0x54, 'ld D, H')
        self.add_instruction(0x55, 'ld D, L')
        self.add_instruction(0x56, 'ld D, [HL]')
        self.add_instruction(0x58, 'ld E, B')
        self.add_instruction(0x59, 'ld E, C')
        self.add_instruction(0x5A, 'ld E, D')
        self.add_instruction(0x5B, 'ld E, E')
        self.add_instruction(0x5C, 'ld E, H')
        self.add_instruction(0x5D, 'ld E, L')
        self.add_instruction(0x5E, 'ld E, [HL]')
        self.add_instruction(0x60, 'ld H, B')
        self.add_instruction(0x61, 'ld H, C')
        self.add_instruction(0x62, 'ld H, D')
        self.add_instruction(0x63, 'ld H, E')
        self.add_instruction(0x64, 'ld H, H')
        self.add_instruction(0x65, 'ld H, L')
        self.add_instruction(0x66, 'ld H, [HL]')
        self.add_instruction(0x68, 'ld L, B')
        self.add_instruction(0x69, 'ld L, C')
        self.add_instruction(0x6A, 'ld L, D')
        self.add_instruction(0x6B, 'ld L, E')
        self.add_instruction(0x6C, 'ld L, H')
        self.add_instruction(0x6D, 'ld L, L')
        self.add_instruction(0x6E, 'ld L, [HL]')
        self.add_instruction(0x70, 'ld [HL], B')
        self.add_instruction(0x71, 'ld [HL], C')
        self.add_instruction(0x72, 'ld [HL], D')
        self.add_instruction(0x73, 'ld [HL], E')
        self.add_instruction(0x74, 'ld [HL], H')
        self.add_instruction(0x75, 'ld [HL], L')
        self.add_instruction(0x36, lambda ctx: Disassembly('ld [HL], {n}', n=ctx.pop8()))
        self.add_instruction(0x0A, 'ld A, [BC]')
        self.add_instruction(0x1A, 'ld A, [DE]')
        self.add_instruction(0xFA, lambda ctx: Disassembly('ld A, [{nn}]', nn=ctx.reference(ctx.pop16_ls_first())))
        self.add_instruction(0x3E, lambda ctx: Disassembly('ld A, {n}', n=ctx.pop8()))
        self.add_instruction(0x47, 'ld B, A')
        self.add_instruction(0x4F, 'ld C, A')
        self.add_instruction(0x57, 'ld D, A')
        self.add_instruction(0x5F, 'ld E, A')
        self.add_instruction(0x67, 'ld H, A')
        self.add_instruction(0x6F, 'ld L, A')
        self.add_instruction(0x02, 'ld [BC], A')
        self.add_instruction(0x12, 'ld [DE], A')
        self.add_instruction(0x77, 'ld [HL], A')
        self.add_instruction(0xEA, lambda ctx: Disassembly('ld [{nn}], A', nn=ctx.reference(ctx.pop16_ls_first())))
        self.add_instruction(0xF2, 'ld A, [C]')
        self.add_instruction(0xE2, 'ld [$FF00+C], A')
        self.add_instruction(0x3A, 'ldd A, [HL]')
        self.add_instruction(0x32, 'ldd [HL], A')
        self.add_instruction(0x2A, 'ldi A, [HL]')
        self.add_instruction(0x22, 'ldi [HL], A')
        self.add_instruction(0xE0, lambda ctx: Disassembly('ld [{n}], A', n=ctx.reference(ctx.pop8(), offset=0xFF00)))
        self.add_instruction(0xF0, lambda ctx: Disassembly('ld A, [{n}]', n=ctx.reference(ctx.pop8(), offset=0xFF00)))
        self.add_instruction(0x01, lambda ctx: Disassembly('ld BC, {nn}', nn=ctx.reference(ctx.pop16_ls_first())))
        self.add_instruction(0x11, lambda ctx: Disassembly('ld DE, {nn}', nn=ctx.reference(ctx.pop16_ls_first())))
        self.add_instruction(0x21, lambda ctx: Disassembly('ld HL, {nn}', nn=ctx.reference(ctx.pop16_ls_first())))
        self.add_instruction(0x31, lambda ctx: Disassembly('ld SP, {nn}', nn=ctx.reference(ctx.pop16_ls_first())))
        self.add_instruction(0xF9, 'ld SP, HL')
        self.add_instruction(0xF8, lambda ctx: Disassembly('ldhl SP, {n}', n=ctx.pop8()))
        self.add_instruction(0x08, lambda ctx: Disassembly('ld [{nn}], SP', nn=ctx.reference(ctx.pop16_ls_first())))
        self.add_instruction(0xF5, 'push AF')
        self.add_instruction(0xC5, 'push BC')
        self.add_instruction(0xD5, 'push DE')
        self.add_instruction(0xE5, 'push HL')
        self.add_instruction(0xF1, 'pop AF')
        self.add_instruction(0xC1, 'pop BC')
        self.add_instruction(0xD1, 'pop DE')
        self.add_instruction(0xE1, 'pop HL')
        self.add_instruction(0x87, 'add A,A')
        self.add_instruction(0x80, 'add A,B')
        self.add_instruction(0x81, 'add A,C')
        self.add_instruction(0x82, 'add A,D')
        self.add_instruction(0x83, 'add A,E')
        self.add_instruction(0x84, 'add A,H')
        self.add_instruction(0x85, 'add A,L')
        self.add_instruction(0x86, 'add A,[HL]')
        self.add_instruction(0xC6, lambda ctx: Disassembly('add A, {n}', n=ctx.pop8()))
        self.add_instruction(0x8F, 'adc A,A')
        self.add_instruction(0x88, 'adc A,B')
        self.add_instruction(0x89, 'adc A,C')
        self.add_instruction(0x8A, 'adc A,D')
        self.add_instruction(0x8B, 'adc A,E')
        self.add_instruction(0x8C, 'adc A,H')
        self.add_instruction(0x8D, 'adc A,L')
        self.add_instruction(0x8E, 'adc A,[HL]')
        self.add_instruction(0xCE, lambda ctx: Disassembly('adc A, {n}', n=ctx.pop8()))
        self.add_instruction(0x97, 'sub A')
        self.add_instruction(0x90, 'sub B')
        self.add_instruction(0x91, 'sub C')
        self.add_instruction(0x92, 'sub D')
        self.add_instruction(0x93, 'sub E')
        self.add_instruction(0x94, 'sub H')
        self.add_instruction(0x95, 'sub L')
        self.add_instruction(0x96, 'sub [HL]')
        self.add_instruction(0xD6, lambda ctx: Disassembly('sub {n}', n=ctx.pop8()))
        self.add_instruction(0x9F, 'sbc A,A')
        self.add_instruction(0x98, 'sbc A,B')
        self.add_instruction(0x99, 'sbc A,C')
        self.add_instruction(0x9A, 'sbc A,D')
        self.add_instruction(0x9B, 'sbc A,E')
        self.add_instruction(0x9C, 'sbc A,H')
        self.add_instruction(0x9D, 'sbc A,L')
        self.add_instruction(0x9E, 'sbc A,[HL]')
        # self.add_instruction( $??, 'sbc A,#')
        self.add_instruction(0xA7, 'and A')
        self.add_instruction(0xA0, 'and B')
        self.add_instruction(0xA1, 'and C')
        self.add_instruction(0xA2, 'and D')
        self.add_instruction(0xA3, 'and E')
        self.add_instruction(0xA4, 'and H')
        self.add_instruction(0xA5, 'and L')
        self.add_instruction(0xA6, 'and [HL]')
        self.add_instruction(0xE6, lambda ctx: Disassembly('and {n}', n=ctx.pop8()))
        self.add_instruction(0xB7, 'or A')
        self.add_instruction(0xB0, 'or B')
        self.add_instruction(0xB1, 'or C')
        self.add_instruction(0xB2, 'or D')
        self.add_instruction(0xB3, 'or E')
        self.add_instruction(0xB4, 'or H')
        self.add_instruction(0xB5, 'or L')
        self.add_instruction(0xB6, 'or [HL]')
        self.add_instruction(0xF6, lambda ctx: Disassembly('or {n}', n=ctx.pop8()))
        self.add_instruction(0xAF, 'xor A')
        self.add_instruction(0xA8, 'xor B')
        self.add_instruction(0xA9, 'xor C')
        self.add_instruction(0xAA, 'xor D')
        self.add_instruction(0xAB, 'xor E')
        self.add_instruction(0xAC, 'xor H')
        self.add_instruction(0xAD, 'xor L')
        self.add_instruction(0xAE, 'xor [HL]')
        self.add_instruction(0xEE, lambda ctx: Disassembly('xor {n}', n=ctx.pop8()))
        self.add_instruction(0xBF, 'cp A')
        self.add_instruction(0xB8, 'cp B')
        self.add_instruction(0xB9, 'cp C')
        self.add_instruction(0xBA, 'cp D')
        self.add_instruction(0xBB, 'cp E')
        self.add_instruction(0xBC, 'cp H')
        self.add_instruction(0xBD, 'cp L')
        self.add_instruction(0xBE, 'cp [HL]')
        self.add_instruction(0xFE, lambda ctx: Disassembly('cp {n}', n=ctx.pop8()))
        self.add_instruction(0x3C, 'inc A')
        self.add_instruction(0x04, 'inc B')
        self.add_instruction(0x0C, 'inc C')
        self.add_instruction(0x14, 'inc D')
        self.add_instruction(0x1C, 'inc E')
        self.add_instruction(0x24, 'inc H')
        self.add_instruction(0x2C, 'inc L')
        self.add_instruction(0x34, 'inc [HL]')
        self.add_instruction(0x3D, 'dec A')
        self.add_instruction(0x05, 'dec B')
        self.add_instruction(0x0D, 'dec C')
        self.add_instruction(0x15, 'dec D')
        self.add_instruction(0x1D, 'dec E')
        self.add_instruction(0x25, 'dec H')
        self.add_instruction(0x2D, 'dec L')
        self.add_instruction(0x35, 'dec [HL]')
        self.add_instruction(0x09, 'add HL, BC')
        self.add_instruction(0x19, 'add HL, DE')
        self.add_instruction(0x29, 'add HL, HL')
        self.add_instruction(0x39, 'add HL, SP')
        # ret pe???
        self.add_instruction(0xE8, lambda ctx: Disassembly('add SP, {n}', n=ctx.pop8_signed()))
        self.add_instruction(0x03, 'inc BC')
        self.add_instruction(0x13, 'inc DE')
        self.add_instruction(0x23, 'inc HL')
        self.add_instruction(0x33, 'inc SP')
        self.add_instruction(0x0B, 'dec BC')
        self.add_instruction(0x1B, 'dec DE')
        self.add_instruction(0x2B, 'dec HL')
        self.add_instruction(0x3B, 'dec SP')

        # 16 bit opcodes
        self.add_instruction(0xCB),

        self.add_instruction(bytes([0xCB, 0x37]), 'swap A')
        self.add_instruction(bytes([0xCB, 0x30]), 'swap B')
        self.add_instruction(bytes([0xCB, 0x31]), 'swap C')
        self.add_instruction(bytes([0xCB, 0x32]), 'swap D')
        self.add_instruction(bytes([0xCB, 0x33]), 'swap E')
        self.add_instruction(bytes([0xCB, 0x34]), 'swap H')
        self.add_instruction(bytes([0xCB, 0x35]), 'swap L')
        self.add_instruction(bytes([0xCB, 0x36]), 'swap [HL]')

        # 0 ARGUMENTS

        self.add_instruction(0x27, 'daa')
        self.add_instruction(0x2F, 'cpl')
        self.add_instruction(0x3F, 'ccf')
        self.add_instruction(0x37, 'scf')
        self.add_instruction(0x00, 'nop')
        self.add_instruction(0x76, lambda ctx: ctx.halt(Disassembly('halt')))
        self.add_instruction(bytes([0x10, 0]), lambda ctx: ctx.halt(Disassembly('stop')))
        self.add_instruction(0xF3, 'di')
        self.add_instruction(0xFB, 'ei')
        self.add_instruction(0x07, 'rlca')
        self.add_instruction(0x17, 'rla')
        self.add_instruction(0x0F, 'rrca')
        self.add_instruction(0x1F, 'rra')

        # 16 BIT OPCODES!

        self.add_instruction(bytes([0xCB, 0x07]), 'rlc A')
        self.add_instruction(bytes([0xCB, 0x00]), 'rlc B')
        self.add_instruction(bytes([0xCB, 0x01]), 'rlc C')
        self.add_instruction(bytes([0xCB, 0x02]), 'rlc D')
        self.add_instruction(bytes([0xCB, 0x03]), 'rlc E')
        self.add_instruction(bytes([0xCB, 0x04]), 'rlc H')
        self.add_instruction(bytes([0xCB, 0x05]), 'rlc L')
        self.add_instruction(bytes([0xCB, 0x06]), 'rlc [HL]')
        self.add_instruction(bytes([0xCB, 0x17]), 'rl A')
        self.add_instruction(bytes([0xCB, 0x10]), 'rl B')
        self.add_instruction(bytes([0xCB, 0x11]), 'rl C')
        self.add_instruction(bytes([0xCB, 0x12]), 'rl D')
        self.add_instruction(bytes([0xCB, 0x13]), 'rl E')
        self.add_instruction(bytes([0xCB, 0x14]), 'rl H')
        self.add_instruction(bytes([0xCB, 0x15]), 'rl L')
        self.add_instruction(bytes([0xCB, 0x16]), 'rl [HL]')
        self.add_instruction(bytes([0xCB, 0x0F]), 'rrc A')
        self.add_instruction(bytes([0xCB, 0x08]), 'rrc B')
        self.add_instruction(bytes([0xCB, 0x09]), 'rrc C')
        self.add_instruction(bytes([0xCB, 0x0A]), 'rrc D')
        self.add_instruction(bytes([0xCB, 0x0B]), 'rrc E')
        self.add_instruction(bytes([0xCB, 0x0C]), 'rrc H')
        self.add_instruction(bytes([0xCB, 0x0D]), 'rrc L')
        self.add_instruction(bytes([0xCB, 0x0E]), 'rrc [HL]')
        self.add_instruction(bytes([0xCB, 0x1F]), 'rr A')
        self.add_instruction(bytes([0xCB, 0x18]), 'rr B')
        self.add_instruction(bytes([0xCB, 0x19]), 'rr C')
        self.add_instruction(bytes([0xCB, 0x1A]), 'rr D')
        self.add_instruction(bytes([0xCB, 0x1B]), 'rr E')
        self.add_instruction(bytes([0xCB, 0x1C]), 'rr H')
        self.add_instruction(bytes([0xCB, 0x1D]), 'rr L')
        self.add_instruction(bytes([0xCB, 0x1E]), 'rr [HL]')
        self.add_instruction(bytes([0xCB, 0x27]), 'sla A')
        self.add_instruction(bytes([0xCB, 0x20]), 'sla B')
        self.add_instruction(bytes([0xCB, 0x21]), 'sla C')
        self.add_instruction(bytes([0xCB, 0x22]), 'sla D')
        self.add_instruction(bytes([0xCB, 0x23]), 'sla E')
        self.add_instruction(bytes([0xCB, 0x24]), 'sla H')
        self.add_instruction(bytes([0xCB, 0x25]), 'sla L')
        self.add_instruction(bytes([0xCB, 0x26]), 'sla [HL]')
        self.add_instruction(bytes([0xCB, 0x2F]), 'sra A')
        self.add_instruction(bytes([0xCB, 0x28]), 'sra B')
        self.add_instruction(bytes([0xCB, 0x29]), 'sra C')
        self.add_instruction(bytes([0xCB, 0x2A]), 'sra D')
        self.add_instruction(bytes([0xCB, 0x2B]), 'sra E')
        self.add_instruction(bytes([0xCB, 0x2C]), 'sra H')
        self.add_instruction(bytes([0xCB, 0x2D]), 'sra L')
        self.add_instruction(bytes([0xCB, 0x2E]), 'sra [HL]')
        self.add_instruction(bytes([0xCB, 0x3F]), 'srl A')
        self.add_instruction(bytes([0xCB, 0x38]), 'srl B')
        self.add_instruction(bytes([0xCB, 0x39]), 'srl C')
        self.add_instruction(bytes([0xCB, 0x3A]), 'srl D')
        self.add_instruction(bytes([0xCB, 0x3B]), 'srl E')
        self.add_instruction(bytes([0xCB, 0x3C]), 'srl H')
        self.add_instruction(bytes([0xCB, 0x3D]), 'srl L')
        self.add_instruction(bytes([0xCB, 0x3E]), 'srl [HL]')

        # GENERATE bit, set and res instructions
        def get_bit(a, b):
            return (b & 0b00111000) >> 3
        def get_bit_reg(a, b):
            return (*'BCDEHL', '[HL]', 'A')[b & 0b111]

        self.add_instruction_range(
            start=0xCB40,
            end=0xCB7F + 1,
            action=lambda ctx: Disassembly(
                'bit {b}, {reg}',
                b=get_bit(*ctx.opcode),
                reg=get_bit_reg(*ctx.opcode)))

        self.add_instruction_range(
            start=0xCBC0,
            end=0xCBFF + 1,
            action=lambda ctx: Disassembly(
                'set {b}, {reg}',
                b=get_bit(*ctx.opcode),
                reg=get_bit_reg(*ctx.opcode)))

        self.add_instruction_range(
            start=0xCB80,
            end=0xCBBF + 1,
            action=lambda ctx: Disassembly(
                'res {b}, {reg}',
                b=get_bit(*ctx.opcode),
                reg=get_bit_reg(*ctx.opcode)))
        # 8 bit opcode!
        self.add_instruction(0xC3, lambda ctx: Disassembly('jp {nn}', nn=ctx.jump(ctx.pop16_ls_first())))
        self.add_instruction(0xC2, lambda ctx: Disassembly('jp NZ, {nn}', nn=ctx.jump(ctx.pop16_ls_first(), conditional=True)))
        self.add_instruction(0xCA, lambda ctx: Disassembly('jp Z, {nn}', nn=ctx.jump(ctx.pop16_ls_first(), conditional=True)))
        self.add_instruction(0xD2, lambda ctx: Disassembly('jp NC, {nn}', nn=ctx.jump(ctx.pop16_ls_first(), conditional=True)))
        self.add_instruction(0xDA, lambda ctx: Disassembly('jp C, {nn}', nn=ctx.jump(ctx.pop16_ls_first(), conditional=True)))
        # THIS JUMP CANNOT BE DEDUCED!
        self.add_instruction(0xE9, lambda ctx: ctx.ret(Disassembly('jp [HL]')))
        # signed byte n
        self.add_instruction(0x18, lambda ctx: Disassembly('jr {n}', n=ctx.jump(offset=ctx.pop8_signed())))
        # * is signed byte
        self.add_instruction(0x20, lambda ctx: Disassembly('jr NZ, {n}', n=ctx.jump(offset=ctx.pop8_signed(), conditional=True)))
        self.add_instruction(0x28, lambda ctx: Disassembly('jr Z, {n}', n=ctx.jump(offset=ctx.pop8_signed(), conditional=True)))
        self.add_instruction(0x30, lambda ctx: Disassembly('jr NC, {n}', n=ctx.jump(offset=ctx.pop8_signed(), conditional=True)))
        self.add_instruction(0x38, lambda ctx: Disassembly('jr C, {n}', n=ctx.jump(offset=ctx.pop8_signed(), conditional=True)))
        self.add_instruction(0xCD, lambda ctx: Disassembly('call {n}', n=ctx.call(ctx.pop16_ls_first())))
        self.add_instruction(0xC4, lambda ctx: Disassembly('call NZ, {nn}', nn=ctx.call(ctx.pop16_ls_first(), conditional=True)))
        self.add_instruction(0xCC, lambda ctx: Disassembly('call Z, {nn}', nn=ctx.call(ctx.pop16_ls_first(), conditional=True)))
        self.add_instruction(0xD4, lambda ctx: Disassembly('call NC, {nn}', nn=ctx.call(ctx.pop16_ls_first(), conditional=True)))
        self.add_instruction(0xDC, lambda ctx: Disassembly('call C, {nn}', nn=ctx.call(ctx.pop16_ls_first(), conditional=True)))
        self.add_instruction(0xC7, lambda ctx: Disassembly('rst {n}', n=ctx.jump(0x0)))
        self.add_instruction(0xCF, lambda ctx: Disassembly('rst {n}', n=ctx.jump(0x8)))
        self.add_instruction(0xD7, lambda ctx: Disassembly('rst {n}', n=ctx.jump(0x10)))
        self.add_instruction(0xDF, lambda ctx: Disassembly('rst {n}', n=ctx.jump(0x18)))
        self.add_instruction(0xE7, lambda ctx: Disassembly('rst {n}', n=ctx.jump(0x20)))
        self.add_instruction(0xEF, lambda ctx: Disassembly('rst {n}', n=ctx.jump(0x28)))
        self.add_instruction(0xF7, lambda ctx: Disassembly('rst {n}', n=ctx.jump(0x30)))
        self.add_instruction(0xFF, lambda ctx: Disassembly('rst {n}', n=ctx.jump(0x38)))
        self.add_instruction(0xC9, lambda ctx: ctx.ret(Disassembly('ret')))
        self.add_instruction(0xC0, lambda ctx: ctx.ret(Disassembly('ret NZ')))
        self.add_instruction(0xC8, lambda ctx: ctx.ret(Disassembly('ret Z')))
        self.add_instruction(0xD0, lambda ctx: ctx.ret(Disassembly('ret NC')))
        self.add_instruction(0xD8, lambda ctx: ctx.ret(Disassembly('ret C')))
        self.add_instruction(0xD9, lambda ctx: ctx.ret(Disassembly('reti')))